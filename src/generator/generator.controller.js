'use strict';

const _ = require('lodash');
const P = require('bluebird');
const etag = require('etag');

const errors = require('../errors');
const inventory = require('../connectors/inventory');
const templates = require('../templates/static');
const SpecialPlay = require('./plays/SpecialPlay');
const format = require('./format');
const identifiers = require('../util/identifiers');
const erratumPlayAggregator = require('./erratumPlayAggregator');
const issueManager = require('../issues');
const log = require('../util/log');

exports.playbookPipeline = async function ({issues, auto_reboot = true}, remediation = false, strict = true) {
    await resolveSystems(issues, strict);
    issues.forEach(issue => issue.id = identifiers.parse(issue.id));

    issues = await P.map(issues, issue => issueManager.getPlayFactory(issue.id).createPlay(issue, strict).catch((e) => {
        if (strict) {
            throw e;
        }

        log.warn(e, `Skipping unknown issue: ${issue.id}`);
    })).filter(issue => issue);

    if (issues.length === 0) {
        return;
    }

    issues = erratumPlayAggregator.process(issues);
    issues = addRebootPlay(issues, auto_reboot);
    issues = addPostRunCheckIn(issues);
    issues = addDiagnosisPlay(issues, remediation);

    const playbook = format.render(issues, remediation);
    format.validate(playbook);

    return playbook;
};

exports.generate = errors.async(async function (req, res) {
    const input = { ...req.body };
    const playbook = await exports.playbookPipeline(input);
    return exports.send(req, res, playbook);
});

async function resolveSystems (issues, strict = true) {
    const systemIds = _(issues).flatMap('systems').uniq().value();

    // bypass cache as ansible_host may change so we want to grab the latest one
    const systems = await inventory.getSystemDetailsBatch(systemIds, true);

    if (!strict) {
        issues.forEach(issue => issue.systems = issue.systems.filter((id) => {
            // eslint-disable-next-line security/detect-object-injection
            return (systems.hasOwnProperty(id));
        }));
    }

    issues.forEach(issue => issue.hosts = issue.systems.map(id => {
        if (!systems.hasOwnProperty(id)) {
            throw errors.unknownSystem(id);
        }

        // validated by openapi middleware and also above
        // eslint-disable-next-line security/detect-object-injection
        const system = systems[id];
        return system.display_name || system.hostname || system.id;
    }));

    if (!strict) {
        issues = issues.filter((issue) => (issue.systems.length > 0));
    }

    return issues;
}

function addRebootPlay (plays, autoReboot = true) {
    const rebootRequiringPlays = _.filter(plays, play => play.needsReboot());
    if (rebootRequiringPlays.length === 0) {
        return plays;
    }

    const hosts = _(rebootRequiringPlays).flatMap('hosts').uniq().sort().value();
    return [
        ...plays,
        new SpecialPlay('special:reboot', hosts, autoReboot ? templates.special.reboot : templates.special.rebootSuppressed)
    ];
}

function addPostRunCheckIn (plays) {
    const hosts = _(plays).flatMap('hosts').uniq().sort().value();
    return [...plays, new SpecialPlay('special:post-run-check-in', hosts, templates.special.postRunCheckIn)];
}

function addDiagnosisPlay (plays, remediation = false) {
    const diagnosisPlays = plays.filter(play => play.needsDiagnosis());

    if (!diagnosisPlays.length) {
        return plays;
    }

    const hosts = _(diagnosisPlays).flatMap('hosts').uniq().sort().value();
    const params = {REMEDIATION: remediation ? ` ${remediation.id}` : ''};
    return [new SpecialPlay('special:diagnosis', hosts, templates.special.diagnosis, params), ...plays];
}

exports.send = function (req, res, playbook, attachment = false) {
    res.set('Content-type', 'text/vnd.yaml');
    res.set('etag', playbookEtag(playbook));

    if (attachment) {
        res.set('Content-disposition', `attachment;filename="${attachment}"`);
    }

    if (req.stale) {
        res.send(playbook).end();
    } else {
        res.status(304).end();
    }
};

// remove timestamps and version info as versions of playbook templates sometimes change even if the template itself does not
function playbookEtag (playbook) {
    playbook = playbook.replace(/^# Generated by Red Hat Insights on .*$/m, '#');
    playbook = playbook.replace(/^# Version: .*$/m, '#');
    return etag(playbook, { weak: true });
}
